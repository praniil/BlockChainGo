package main

import (
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io"
	"math/big"
	"os"
	"strconv"
	"strings"
	"time"
)

type Block struct {
	data      map[string]interface{}
	hash      string
	prevHash  string
	timestamp time.Time
	nonce     int
}

type userProfile struct {
	name         string
	amount       float32
	publicKey    rsa.PublicKey
	privateKey   rsa.PrivateKey
	TotalBitcoin float32
}

// Blockchain containing Blocks
type BlockChain struct {
	genesisBlock Block
	chain        []Block
	target       int
}

func (user *userProfile) createUser(name string, userBlockChain *[]string, amount float32) {
	//amount hard coded, public and private key generated by generateKeyPair
	*userBlockChain = append(*userBlockChain, name)
	user.name = name
	user.amount = amount
	user.generateKeyPair()
}

//to include a block into a blockchain a miner mines a new block calculating a hash puzzle
//calculation of the hash of the block
//it includes the hashing of transactions(data), nonce, prevHash to create the new hash of the block

func (user *userProfile) generateKeyPair() {
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		fmt.Println("Error generating RSA private key:", err)
		os.Exit(1) //0 indicated success and non zero indicate non success
	}

	privateKeyPEM := &pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
	}

	privateKeyFile, err := os.Create(user.name + "privateKey.pem")
	if err != nil {
		fmt.Println("Error creating private key file: ", err)
		os.Exit(1)
	}

	//encode it into a pem file
	pem.Encode(privateKeyFile, privateKeyPEM)
	privateKeyFile.Close()

	publicKey := &privateKey.PublicKey

	publicKeyFile, err := os.Create(user.name + "publicKey.pem")
	if err != nil {
		fmt.Println("Error creating public key file: ", err)
		os.Exit(1)
	}

	publicKeyPem := &pem.Block{
		Type:  "RSA PUBLIC KEY",
		Bytes: x509.MarshalPKCS1PublicKey(publicKey),
	}

	pem.Encode(publicKeyFile, publicKeyPem)
	publicKeyFile.Close()
	user.privateKey = *privateKey
	user.publicKey = *publicKey
	// fmt.Printf("User: %s \n, public key: %v \n, private Key: %v \n", user.name, user.publicKey, user.privateKey)
}

func verifySignature(user string, block map[string]interface{}) bool {
	file, err := os.Open("/home/pranil/goProjects/BlockChainGo/" + user + "privateKey.pem")
	if err != nil {
		fmt.Println("couldnot open privateKey.rem file", err)
		os.Exit(1)
	}
	defer file.Close()
	privateKeyFile, err := io.ReadAll(file)
	if err != nil {
		fmt.Println("couldnt read privateKey from the file", err)
	}
	privateKeyBlock, _ := pem.Decode(privateKeyFile)
	// fmt.Println(privateKeyBlock.Bytes)
	privateKey, err := x509.ParsePKCS1PrivateKey(privateKeyBlock.Bytes)
	if err != nil {
		fmt.Println("error parsing the private key: ", err)
	}
	//signature

	// var message []byte = []byte(msg)
	blockJson, err := json.Marshal(block)
	if err != nil {
		fmt.Println("error marshalling block to JSON: ", err)
	}
	hash := sha256.Sum256(blockJson)
	signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hash[:])
	if err != nil {
		fmt.Println("Error signing message: ", err)
		os.Exit(1)
	}

	//public key load
	pubFile, err := os.Open("/home/pranil/goProjects/BlockChainGo/" + user + "publicKey.pem")
	if err != nil {
		fmt.Println("couldnot open publicKey.rem file", err)
		os.Exit(1)
	}
	defer pubFile.Close()
	publicKeyFile, err := io.ReadAll(pubFile)
	if err != nil {
		fmt.Println("error reading from the file", err)
		os.Exit(1)
	}
	publicKeyBlock, _ := pem.Decode(publicKeyFile)
	publicKey, err := x509.ParsePKCS1PublicKey(publicKeyBlock.Bytes)
	if err != nil {
		fmt.Println("Error parsing public key:", err)
		os.Exit(1)
	}

	//verify
	err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hash[:], signature)
	if err != nil {
		fmt.Println("Error verifying signature:", err)
		return false
	}
	return true
}

func (b Block) calculateHash() string {
	data, err := json.Marshal(b.data)
	if err != nil {
		fmt.Printf("error in encoding the data: %v", err)
	}
	blockData := b.prevHash + string(data) + b.timestamp.String() + strconv.Itoa(b.nonce)
	newHash := sha256.Sum256([]byte(blockData))
	return fmt.Sprintf("%x", newHash)
}

func (b *Block) mine(miner string, target int) {
	for !strings.HasPrefix(b.hash, strings.Repeat("0", target)) {
		b.nonce++
		b.hash = b.calculateHash()
	}
	
}

func CreatBlockchain(target int) BlockChain {
	genesisblock := Block{
		hash:      "0",
		timestamp: time.Now(),
	}
	return BlockChain{
		genesisblock,
		[]Block{genesisblock},
		target,
	}
}

func (b *BlockChain) addBlock(user userProfile, to userProfile, userBlockChain *[]string, amount float64) {
	blockData := map[string]interface{}{
		"from":   user.name,
		"to":     to.name,
		"amount": amount,
	}
	prevBlock := b.chain[len(b.chain)-1]
	validity := verifySignature(user.name, blockData)
	if float64(user.amount) < amount {
		fmt.Printf("the user %s doesnt have enough BTC to transfer \n", user.name)
	} else {
		if validity {
			newBlock := Block{
				data:      blockData,
				prevHash:  prevBlock.hash,
				timestamp: time.Now(),
			}
			length := len(*userBlockChain)
			randomNumber, err := rand.Int(rand.Reader, big.NewInt(int64(length)))
			if err != nil {
				fmt.Println("Error generating random number:", err)
				return
			}
			miner := (*userBlockChain)[randomNumber.Int64()]
			fmt.Println("miner", miner)
			newBlock.mine(miner, b.target)
			b.chain = append(b.chain, newBlock)
		} else {
			fmt.Printf("the user %s is not verified: ", user.name)
		}
	}
}

func (b *BlockChain) isValid() bool {
	fmt.Println(b.chain)
	for i := range b.chain[1:] {
		previousBlock := b.chain[i]
		currentBlock := b.chain[i+1]
		if currentBlock.hash != currentBlock.calculateHash() || currentBlock.prevHash != previousBlock.hash {
			return false
		}
	}
	return true
}

func main() {
	// const blockReward = 6.25
	blockchain := CreatBlockchain(2)
	// var userAlice, userBob userProfile
	userAlice := userProfile{name: "Alice"}
	userBob := userProfile{name: "Bob"}
	userBlockChain := make([]string, 0, 100)
	userAlice.createUser(userAlice.name, &userBlockChain, 3.4)
	userBob.createUser(userBob.name, &userBlockChain, 5.2)
	// userJohn.createUser(userJohn.name, 6.7)
	blockchain.addBlock(userAlice, userBob, &userBlockChain, 1)
	blockchain.addBlock(userAlice, userBob, &userBlockChain, 2)
	// fmt.Println(blockchain.chain)
	fmt.Println(blockchain.isValid())
	fmt.Println(userBlockChain)
}
